## Task 1: Logic for extracting join conditions from the WHERE clause

### 1. Initialization and preparation phase
- **Collect connection information:** First, the method receives a list of all table names participating in the connection (`joinedTableNames`) and an instance of `JoinExpressionDeParser`, which contains the parsed connection conditions.
- **Prepare cumulative `schema`:** To properly handle columns in joins, an `accumulatedSchema` is maintained that progressively expands as each join table is traversed to include columns from all previous tables.
### 2. Traverse and process each connection
- Method loops through each table name in the `joinedTableNames` list. For each table name in the list:
  - **Resolve table names and aliases:** If the table name contains aliases (that is, names separated by Spaces), it is processed accordingly to ensure that the column name can be referenced correctly.
  - **Prepare selection criteria:** The selection criteria collected through `JoinExpressionDeParser` are checked to determine which criteria are applied to the currently traversed table. This step is achieved by comparing the table names or aliases involved in the condition.
  - **Build `SelectOperator`:** Create a `selectoperator` for the current table, applying all relevant selection criteria. This means that rows that do not meet the criteria are filtered out before a physical connection is made.
### 3. Apply connection and build connection operators
- For the first table in the list, use the selection operator built in the previous step directly as the starting point.
- For subsequent tables, do the following:
    - **Cumulative `schema`:**  Adds the `schema` of the current table to the cumulative schema. If you use aliases, you also need to make sure that the column names in the schema reflect this correctly.
    - **Build join condition:**  For non-first tables, a merged join condition expression is built based on the join condition parsed in `JoinExpressionDeParser`. This expression is generated by comparing the connection conditions of the currently traversed table with all previous tables.
    - **Create `JoinOperator`:**  Create a new `JoinOperator` using the operators from the previous step, the selection operators from the current table, and the constructed join conditions. This operator is responsible for performing the actual join logic, concatenating the output of the previous operator to the current table.

### 4. Update the cumulative schema and return the final operator
- At the end of each loop, the accumulated schema is updated to include the columns of the currently processed table.
- When the loop completes, the last constructed connection operator is returned as a result of the connection processing.

## Task 2: How to optimize the query plan

1. Selection Push down. This query plan push down the selection operation before join, which can reduce the amount of data process and the size of the intermediate result set generated by the join operation.

2. Projection Push down. This query plan push down the projection operation before order by, which can reduce the amount of data process and the size of the intermediate result set generated by the order by operation.



## External parameters and paths
We have the following external parameters and paths:
- `databaseDir`: The directory where the database files are stored. For example: `samples/db `
- `inputFile`: The path to the input SQL file. For example: `samples/input/query8.sql`
- `outputFile`: The path to the output file where the query plan will be written. For example: `output/query8.csv`

